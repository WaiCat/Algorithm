## 🧠 알고리즘 문제 코드 분석 - Counting Elements

## 📌 문제 요약
- **문제 이름**: Counting Elements
- **문제 링크**: [LeetCode - Counting Elements](https://leetcode.com/problems/counting-elements/)
- **문제 유형**: Set, Hashing
- **난이도**: Easy
- **요구사항 요약**:
  - 정수 배열 `arr`이 주어질 때, 배열 내에서 `x + 1`이 존재하는 `x`의 개수를 세어 반환
  - 중복 원소도 각각 세야 하며, 단순히 개수만 구하면 됨

---

## 📥 입력 & 출력 예시

### 입력 예시 1
```java
arr = [1, 2, 3]
```

### 출력 예시 1
```java
2
```

### 입력 예시 2
```java
arr = [1, 1, 3, 3, 5, 5, 7, 7]
```

### 출력 예시 2
```java
0
```

---

## 🔍 접근 방식

- **입력 크기 분석**: 최대 1000 → O(n) 가능
- **알고리즘 선택**: Set 활용
- **이유**: 빠른 탐색을 위해 Set으로 존재 여부를 확인
- **핵심 아이디어**:
  - 먼저 전체 값을 Set에 저장
  - 각 원소에 대해 `i + 1`이 Set에 존재하면 count 증가

---

## 💻 핵심 코드 분석

```java
public static int countElements(int[] arr) {
    int count = 0;
    Set<Integer> set = new HashSet<>();

    for (int i : arr) {
        set.add(i);
    }

    for (int i : arr) {
        if (set.contains(i + 1)) {
            count++;
        }
    }

    return count;
}
```

- **설명**:
  - 첫 번째 루프에서 모든 원소를 Set에 저장 (중복 제거)
  - 두 번째 루프에서 `i + 1`이 Set에 있으면 count 증가

---

## 🧪 예제 테스트

| arr | 기대 출력 | 실제 출력 | 일치 여부 |
|-----|------------|------------|------------|
| `[1, 2, 3]` | `2` | `2` | ✅ |
| `[1, 1, 3, 3, 5, 5, 7, 7]` | `0` | `0` | ✅ |
| `[1, 3, 2, 3, 5, 0]` | `3` | `3` | ✅ |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n)
- **공간복잡도**: O(n) (Set 저장용)

---

## ✅ 최종 정리

- `i + 1`이 존재하는 `i`를 빠르게 찾기 위해 Set을 사용하는 아이디어가 핵심
- 중복 원소도 모두 개별적으로 세야 하므로 Set은 탐색용으로만 사용됨
- 쉬운 난이도이지만 HashSet 응용력을 키우기 좋은 문제