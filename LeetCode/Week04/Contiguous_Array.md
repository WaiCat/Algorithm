## 🧠 알고리즘 문제 코드 분석 - Contiguous Array

## 📌 문제 요약
- **문제 이름**: [Contiguous Array](https://leetcode.com/problems/contiguous-array/description/)
- **문제 유형**: 해시맵, 누적합, 슬라이딩 윈도우
- **난이도**: Medium
- **요구사항 요약**:
  - 이진 배열 `nums`가 주어질 때, 0과 1의 수가 **동일한 가장 긴 연속 부분 배열의 길이**를 반환

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
nums = [0, 1, 1, 1, 1, 1, 0, 0, 0]
```

### 출력 예시
```java
6
```

---

## 🔍 접근 방식

- **입력 크기 분석**: 최대 10⁵ → O(n) 필요
- **알고리즘 선택**: 누적합 + HashMap
- **이유**: 0과 1을 누적합으로 변환해, 동일한 합이 다시 등장하는 구간의 길이를 이용
- **핵심 아이디어**:
  - 0은 -1로 바꾸고 1은 그대로 두어, 누적합이 0이 되는 구간을 탐색
  - 누적합이 같은 값이 **두 번 이상 등장**하면 그 사이 구간의 합은 0 (즉, 0과 1 개수가 같음)

---

## 💻 핵심 코드 분석

```java
public static int findMaxLength(int[] nums) {
    int maxl = 0;
    int sum = 0;

    Map<Integer, Integer> map = new HashMap<>();
    map.put(0, -1);

    for (int i = 0; i < nums.length; i++) {
        sum += nums[i] == 0 ? -1 : 1;

        if (map.containsKey(sum)) {
            maxl = Math.max(maxl, i - map.get(sum));
        } else {
            map.put(sum, i);
        }
    }

    return maxl;
}
```

- **설명**:
  - 0 → -1로 변환
  - 누적합이 같았던 시점의 인덱스를 저장
  - 동일한 누적합이 등장하면 그 사이 길이를 계산해 최대 길이 갱신

---

## 🧪 예제 테스트

| nums | 기대 출력 |
|------|-------------|
| `[0, 1]` | `2` |
| `[0, 1, 0]` | `2` |
| `[0, 1, 1, 1, 1, 1, 0, 0, 0]` | `6` |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n)
- **공간복잡도**: O(n)

---

## ✅ 최종 정리

- 0과 1의 개수를 동일하게 만들기 위해 누적합을 활용
- 누적합이 반복되는 지점 사이 거리가 정답 후보가 되는 전형적인 응용 문제
- 핵심은 0을 -1로 바꾸고 누적합 패턴을 파악하는 사고 전환