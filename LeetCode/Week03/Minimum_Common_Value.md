## 🧠 알고리즘 문제 코드 분석 - Minimum Common Value

## 📌 문제 요약
- **문제 이름**: [Minimum Common Value](https://leetcode.com/problems/minimum-common-value/description/)
- **문제 유형**: Two Pointer
- **난이도**: Easy
- **요구사항 요약**:
  - 정렬된 두 정수 배열 `nums1`, `nums2`가 주어질 때
  - 두 배열 모두에 존재하는 **가장 작은 공통 원소**를 찾아 반환하라
  - 공통 원소가 없다면 `-1` 반환

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
nums1 = {1, 2, 3};
nums2 = {2, 4};
```

### 출력 예시
```java
2
```

---

## 🔍 접근 방식

- **입력 크기 분석**: 배열 길이 최대 10⁵ → O(n) 또는 O(m) 가능
- **알고리즘 선택**: Two Pointer
- **이유**: 정렬된 배열을 동시에 순회하며 공통 원소를 효율적으로 찾을 수 있음
- **핵심 아이디어**:
  - 포인터 두 개를 사용하여 각각 nums1, nums2에서 탐색
  - 값이 같으면 공통 원소이므로 바로 반환
  - 값이 작으면 해당 포인터 증가시킴

---

## 💻 핵심 코드 분석

```java
public static int getCommon(int[] nums1, int[] nums2) {
    int point1 = 0, point2 = 0;

    while (point1 < nums1.length && point2 < nums2.length) {
        if (nums1[point1] == nums2[point2]) {
            return nums1[point1];
        } else if (nums1[point1] < nums2[point2]) {
            point1++;
        } else {
            point2++;
        }
    }
    return -1;
}
```

- **설명**:
  - `nums1[point1] == nums2[point2]`이면 정답
  - 한쪽 값이 작으면 해당 포인터를 증가시켜 정렬 속성을 활용해 탐색

---

## 🧪 예제 테스트

| nums1 | nums2 | 기대 출력 | 실제 출력 | 일치 여부 |
|--------|--------|--------------|--------------|------------|
| `[1, 2, 3]` | `[2, 4]` | `2` | `2` | ✅ |
| `[1, 2, 3, 6]` | `[4, 5, 6]` | `6` | `6` | ✅ |
| `[1, 3, 5]` | `[2, 4, 6]` | `-1` | `-1` | ✅ |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n + m) (n, m은 배열 길이)
- **공간복잡도**: O(1)

---

## ✅ 최종 정리

- 정렬된 두 배열의 공통 원소 탐색에서 **투 포인터**는 가장 효율적인 방식
- 정렬된 상태를 유지하므로 한쪽 포인터만 증가시키면 불필요한 비교를 줄일 수 있음
- 공통 원소 중 가장 작은 값을 찾는 문제에서 즉시 반환으로 최적화 가능