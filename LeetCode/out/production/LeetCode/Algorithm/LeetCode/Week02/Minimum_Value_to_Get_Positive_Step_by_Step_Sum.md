## 🧠 알고리즘 문제 코드 분석 - Minimum Value to Get Positive Step by Step Sum

## 📌 문제 요약
- **문제 이름**: [Minimum Value to Get Positive Step by Step Sum](https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/description/)
- **문제 유형**: 누적합, 시뮬레이션
- **난이도**: Easy
- **요구사항 요약**:
  - 정수 배열 `nums`가 주어질 때, **누적합(sum)이 항상 양수**가 되도록 하는 최소 시작값 `x`를 구하라
  - `x + nums[0] + ... + nums[i] > 0` 이 항상 성립해야 함

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
nums = [-12]
```

### 출력 예시
```java
13
```

---

## 🔍 접근 방식

- **입력 크기 분석**: 최대 100 → O(n) 가능
- **알고리즘 선택**: 누적합 계산 + 최소값 추적
- **이유**: 누적합 중 최소값을 기록하여 그에 맞는 시작값을 설정 가능
- **핵심 아이디어**:
  - 누적합이 가장 작을 때를 기준으로 양수가 되도록 보정 필요
  - 누적합의 최소값이 `min`이라면, `startValue >= 1 - min`

---

## 💻 핵심 코드 분석

```java
public static int minStartValue(int[] nums) {
    int sum = nums[0];
    int min = sum;

    for (int i = 1; i < nums.length; i++) {
        min = Math.min(sum += nums[i], min);
    }

    if (min < 0) {
        return (min * -1) + 1;
    } else {
        return 1;
    }
}
```

- **설명**:
  - 누적합을 구하면서 최솟값을 기록
  - 최솟값이 음수라면 그만큼 보정하여 양수가 되게 만들기 위해 `-min + 1` 반환
  - 최솟값이 양수이면 기본적으로 시작값 1이면 충분

---

## 🧪 예제 테스트

| nums | 기대 출력 | 실제 출력 | 일치 여부 |
|------|------------|-------------|------------|
| `[-12]` | `13` | `13` | ✅ |
| `[-3, 2, -3, 4, 2]` | `5` | `5` | ✅ |
| `[1, 2]` | `1` | `1` | ✅ |
| `[1, -2, -3]` | `5` | `5` | ✅ |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n)
- **공간복잡도**: O(1)

---

## ✅ 최종 정리

- 누적합이 항상 양수여야 한다는 조건에서 핵심은 **누적합의 최소값**
- 최소 누적합이 음수일 경우 `1 - min`을 시작값으로 설정하면 항상 양수를 유지할 수 있음
- 간단한 아이디어지만 문제 조건 해석이 중요함