## 🧠 알고리즘 문제 코드 분석 - Number of Good Pairs

## 📌 문제 요약
- **문제 이름**: [Number of Good Pairs](https://leetcode.com/problems/number-of-good-pairs/)
- **문제 유형**: 배열, 해시맵
- **난이도**: Easy
- **요구사항 요약**:
  - 정수 배열 `nums`가 주어졌을 때,
  - **(i, j)** (i < j) 쌍 중 `nums[i] == nums[j]`를 만족하는 쌍의 개수를 반환

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
nums = [1, 2, 3, 1, 1, 3]
```

### 출력 예시
```java
4
```

---

## 🔍 접근 방식

- **입력 크기 분석**: 최대 100 → O(n²) 가능하지만 O(n)으로 최적화
- **알고리즘 선택**: HashMap
- **이유**: 등장 횟수를 효율적으로 카운팅하여 좋은 쌍의 개수를 계산
- **핵심 아이디어**:
  - 배열을 순회하면서 해시맵에 숫자의 등장 횟수를 누적 저장
  - 같은 숫자가 등장할 때마다 지금까지의 등장 횟수만큼 결과에 더함

---

## 💻 핵심 코드 분석

```java
public static int numIdenticalPairs(int[] nums) {
    Map<Integer, Integer> map = new HashMap<>();
    int res = 0;

    for (int num : nums) {
        if (map.containsKey(num)) {
            res += map.get(num);
        }
        map.put(num, map.getOrDefault(num, 0) + 1);
    }

    return res;
}
```

- **설명**:
  - 숫자의 등장 횟수를 해시맵에 저장하여 중복이 발생할 때마다 누적된 값을 더함

---

## 🧪 예제 테스트

| nums                       | 기대 출력 |
|----------------------------|-------------|
| `[1, 2, 3, 1, 1, 3]`       | 4           |
| `[1, 1, 1, 1]`             | 6           |
| `[1, 2, 3]`                | 0           |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n) (한 번의 순회)
- **공간복잡도**: O(n) (해시맵 사용)

---

## ✅ 최종 정리

- 주어진 배열에서 좋은 쌍의 개수를 구하는 문제
- 해시맵을 사용하여 등장 횟수를 누적 관리하여 O(n) 시간복잡도로 해결
- 각 숫자의 등장 횟수만큼 좋은 쌍의 개수를 누적하여 반환