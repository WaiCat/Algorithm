## 🧠 알고리즘 문제 코드 분석 - Find the Highest Altitude

## 📌 문제 요약
- **문제 이름**: [Find the Highest Altitude](https://leetcode.com/problems/find-the-highest-altitude/description/)
- **문제 유형**: 누적합 (Prefix Sum)
- **난이도**: Easy
- **요구사항 요약**:
  - `gain[i]`는 i번째 구간에서 얻은 고도 변화
  - 초기 고도는 0이며, 각 구간을 거치며 누적된 고도 중 **가장 높은 고도**를 반환

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
gain = {-5, 1, 5, 0, -7}
```

### 출력 예시
```java
1  // 고도 변화: [0, -5, -4, 1, 1, -6]
```

---

## 🔍 접근 방식

- **입력 크기 분석**: 최대 100 → O(n) 가능
- **알고리즘 선택**: 누적합
- **이유**: 각 지점에서의 고도를 누적하여 최대값 추적
- **핵심 아이디어**:
  - `sum`: 현재까지의 누적 고도
  - `max`: 최고 고도 저장
  - 매 반복마다 `sum`을 갱신하고 `max`를 갱신

---

## 💻 핵심 코드 분석

```java
public static int largestAltitude(int[] gain) {
    int max = 0;
    int sum = 0;
    for (int i = 0; i < gain.length; i++) {
        sum += gain[i];
        max = Math.max(max, sum);
    }
    return max;
}
```

- **설명**:
  - 초기 고도는 0
  - 고도를 누적하면서 최고 고도(max)를 계속 갱신

---

## 🧪 예제 테스트

| gain | 기대 출력 | 실제 출력 | 일치 여부 |
|------|------------|------------|------------|
| `[-5, 1, 5, 0, -7]` | `1` | `1` | ✅ |
| `[-4, -3, -2, -1, 4, 3, 2]` | `0` | `0` | ✅ |
| `[1, 2, 3]` | `6` | `6` | ✅ |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n)
- **공간복잡도**: O(1)

---

## ✅ 최종 정리

- 고도 변화값 배열로부터 누적 고도를 구하며 최대 고도를 추적
- 문제 핵심은 **초기값 0에서 출발하여 누적합의 최대값 찾기**
- 간단한 구현 문제지만 누적합 개념을 잘 이해하고 있어야 함