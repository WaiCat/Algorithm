## 🧠 알고리즘 문제 코드 분석 - K Radius Subarray Averages

## 📌 문제 요약
- **문제 이름**: [K Radius Subarray Averages](https://leetcode.com/problems/k-radius-subarray-averages/description/)
- **문제 유형**: Sliding Window, Prefix Sum
- **난이도**: Medium
- **요구사항 요약**:
  - 정수 배열 `nums`와 정수 `k`가 주어짐
  - 각 인덱스 `i`에서 `i-k`부터 `i+k`까지 범위(총 길이 `2k+1`)의 평균을 구함
  - 범위가 벗어나는 인덱스는 `-1`로 채움
  - 평균은 **정수 나눗셈** (소수점 버림) 사용

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
nums = [7, 4, 3, 9, 1, 8, 5, 2, 6], k = 3
```

### 출력 예시
```java
[-1, -1, -1, 5, 4, 4, -1, -1, -1]
```

---

## 🔍 접근 방식

- **입력 크기 분석**: 최대 10⁵ → O(n) 가능
- **알고리즘 선택**: Sliding Window (고정 크기)
- **이유**: 윈도우의 크기가 고정되어 있고, 이전 합을 활용해 효율적으로 다음 평균을 계산할 수 있음
- **핵심 아이디어**:
  - 처음 윈도우(`2k + 1` 크기)의 합을 구한 뒤, 윈도우를 슬라이딩하면서 한 칸씩 이동
  - 윈도우가 유효한 범위를 벗어나지 않는 인덱스에만 평균을 계산해서 저장

---

## 💻 핵심 코드 분석

```java
public static int[] getAverages(int[] nums, int k) {
    int n = nums.length;
    int[] res = new int[n];
    Arrays.fill(res, -1);

    int windowSize = 2 * k + 1;

    if (n < windowSize) {
        return res;
    }

    long sum = 0;
    for (int i = 0; i < windowSize; i++) {
        sum += nums[i];
    }

    res[k] = (int) (sum / windowSize);

    for (int i = k + 1; i < n - k; i++) {
        sum += nums[i + k];
        sum -= nums[i - k - 1];
        res[i] = (int) (sum / windowSize);
    }

    return res;
}
```

- **설명**:
  - `windowSize`: 중앙 기준 `2k+1`의 길이를 갖는 윈도우
  - `sum`: 현재 윈도우의 합
  - 첫 윈도우 합을 구한 후, 앞 요소 빼고 새 요소 더하는 방식으로 슬라이딩
  - 평균값은 `(int)` 형변환으로 정수 나눗셈 처리

---

## 🧪 예제 테스트

| nums | k | 기대 출력 | 실제 출력 | 일치 여부 |
|------|---|-------------|--------------|------------|
| `[7,4,3,9,1,8,5,2,6]` | 3 | `[-1,-1,-1,5,4,4,-1,-1,-1]` | `[-1,-1,-1,5,4,4,-1,-1,-1]` | ✅ |
| `[1,2,3,4,5]` | 1 | `[-1,2,3,4,-1]` | `[-1,2,3,4,-1]` | ✅ |
| `[5]` | 0 | `[5]` | `[5]` | ✅ |
| `[5]` | 1 | `[-1]` | `[-1]` | ✅ |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n)
- **공간복잡도**: O(n) (결과 배열)

---

## ✅ 최종 정리

- 슬라이딩 윈도우를 활용하여 `O(n)` 시간 안에 전체 평균을 계산 가능
- `long` 타입을 사용하여 합계 오버플로우 방지
- 정수 나눗셈으로 소수점 버림 처리 필요