## 🧠 알고리즘 문제 코드 분석 - Running Sum of 1d Array

## 📌 문제 요약
- **문제 이름**: [Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/description/)
- **문제 유형**: Prefix Sum (누적합)
- **난이도**: Easy
- **요구사항 요약**:
  - 정수 배열 `nums`가 주어졌을 때, 각 인덱스 `i`에 대해 `nums[0] + ... + nums[i]` 값을 가지는 누적합 배열을 반환하라

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
nums = [3, 1, 2, 10, 1]
```

### 출력 예시
```java
[3, 4, 6, 16, 17]
```

---

## 🔍 접근 방식

- **입력 크기 분석**: 최대 10³ → O(n) 충분
- **알고리즘 선택**: 누적합(Prefix Sum)
- **이유**: 앞의 값을 저장하고 더해 나가면 O(n)으로 해결 가능
- **핵심 아이디어**:
  - 결과 배열의 첫 번째 값은 원래 배열의 첫 값과 같음
  - 그 다음부터는 이전까지 누적한 값에 현재 값을 더해 나가는 방식

---

## 💻 핵심 코드 분석

```java
public static int[] runningSum(int[] nums) {
    int[] result = new int[nums.length];
    result[0] = nums[0];
    for (int i = 1; i < nums.length; i++) {
        result[i] = nums[i] + result[i - 1];
    }
    return result;
}
```

- **설명**:
  - 첫 번째 값은 그대로 복사
  - 이후 인덱스부터는 `이전 누적합 + 현재 값` 형태로 계산

---

## 🧪 예제 테스트

| nums | 기대 출력 | 실제 출력 | 일치 여부 |
|------|-----------|-----------|------------|
| `[3, 1, 2, 10, 1]` | `[3, 4, 6, 16, 17]` | `[3, 4, 6, 16, 17]` | ✅ |
| `[1, 2, 3, 4]` | `[1, 3, 6, 10]` | `[1, 3, 6, 10]` | ✅ |
| `[1, 1, 1, 1, 1]` | `[1, 2, 3, 4, 5]` | `[1, 2, 3, 4, 5]` | ✅ |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n)
- **공간복잡도**: O(n) (결과 배열 사용)

---

## ✅ 최종 정리

- 대표적인 누적합 문제로, 매우 직관적인 방식으로 해결 가능
- 단순히 앞에서부터 더해 나가는 방식으로 효율적으로 구현 가능
- 입력 배열을 그대로 누적할 수도 있지만, 여기선 별도 배열 사용