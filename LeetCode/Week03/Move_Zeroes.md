## 🧠 알고리즘 문제 코드 분석 - Move Zeroes

## 📌 문제 요약
- **문제 이름**: [Move Zeroes](https://leetcode.com/problems/move-zeroes/description/)
- **문제 유형**: 배열, 투 포인터, 인플레이스(In-place) 연산
- **난이도**: Easy
- **요구사항 요약**:
  - 주어진 정수 배열 `nums`에서 0을 모두 오른쪽 끝으로 이동시키되, **0이 아닌 요소의 순서는 유지**하라
  - in-place로 해결해야 하며, 추가 배열 사용은 최소화해야 함

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
nums = [0, 1, 0, 3, 12]
```

### 출력 예시
```java
[1, 3, 12, 0, 0]
```

---

## 🔍 접근 방식

- **입력 크기 분석**: 최대 10⁴ → O(n) 가능
- **알고리즘 선택**: Two Pointer (0 위치 추적)
- **이유**: 0이 아닌 숫자들을 앞으로 이동시키고, 남은 자리는 0으로 자동 정렬됨
- **핵심 아이디어**:
  - `zero` 포인터는 0이 나올 자리를 가리킴
  - 0이 아닌 요소를 발견하면, 현재 인덱스와 `zero` 인덱스를 swap
  - swap 후 `zero` 증가

---

## 💻 핵심 코드 분석

```java
public static void moveZeroes(int[] nums) {
    int zero = 0;

    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            int temp = nums[i];
            nums[i] = nums[zero];
            nums[zero] = temp;
            zero++;
        }
    }
}
```

- **설명**:
  - `zero`는 0이 있어야 할 위치를 추적
  - 0이 아닌 값을 만나면 `zero` 위치와 현재 값을 교환하고 포인터 증가
  - 자기 자신과 바꾸는 경우도 있으나 문제 없음

---

## 🧪 예제 테스트

| 입력 | 기대 출력 | 실제 출력 | 일치 여부 |
|------|------------|------------|------------|
| `[0,1,0,3,12]` | `[1,3,12,0,0]` | `[1,3,12,0,0]` | ✅ |
| `[0]` | `[0]` | `[0]` | ✅ |
| `[1,0,1]` | `[1,1,0]` | `[1,1,0]` | ✅ |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n)
- **공간복잡도**: O(1) (in-place)

---

## ✅ 최종 정리

- 투 포인터를 사용해 0을 오른쪽으로 보내면서도 **0이 아닌 요소의 순서 유지**
- `zero`는 다음으로 채울 0이 아닌 값을 가리킴
- in-place로 효율적이고 직관적인 구현