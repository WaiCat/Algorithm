# 🧠 알고리즘 문제 코드 분석 - Reverse String

## 📌 문제 요약
- **문제 이름**: Reverse String
- **문제 링크**: [https://leetcode.com/problems/reverse-string](https://leetcode.com/problems/reverse-string)
- **문제 유형**: Two Pointer, 문자열, 배열
- **난이도**: Easy
- **요구사항 요약**:
  - 주어진 `char[] s` 배열을 **in-place**로 뒤집어야 한다.
  - 추가적인 배열을 사용하지 않고 직접 원래 배열에서 반전해야 한다.
  - 반환값은 없으며, 배열 자체를 수정해야 한다.

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
s = ['h', 'e', 'l', 'l', 'o']
```

### 출력 예시
```java
['o', 'l', 'l', 'e', 'h']
```

---

## 🔍 접근 방식
- **입력 크기 분석**: 최대 길이 10⁵ → O(n) 가능
- **알고리즘 선택**: **양쪽 포인터(Two Pointer)** 사용
- **이유**:
  - 배열을 in-place로 뒤집기 위해선 양 끝에서 값을 교환하면서 중앙으로 수렴하는 방식이 가장 효율적
- **핵심 아이디어**:
  - `left`는 시작 인덱스(0), `right`는 끝 인덱스(`s.length - 1`)
  - 두 인덱스가 만날 때까지 서로의 값을 교환하면서 이동
  - 한 번의 순회로 완성 가능

---

## 💻 핵심 코드 분석

```java
int left = 0;
int right = s.length - 1;

// 양쪽에서 가운데로 오면서 swap
while (left < right) {
    char temp = s[left];      // 왼쪽 문자 임시 저장
    s[left++] = s[right];     // 오른쪽 문자를 왼쪽에 저장하고 left 증가
    s[right--] = temp;        // 임시 저장한 문자를 오른쪽에 저장하고 right 감소
}
```

- **설명**:
  - 이 코드는 배열을 좌우에서 동시에 접근하면서 swap하는 방식
  - `temp` 변수를 통해 값이 덮어쓰기 되지 않게 안전하게 처리
  - `left++`, `right--`를 통해 인덱스를 한 번에 처리

---

## 🧪 예제 테스트

| 입력 | 기대 출력 | 실제 출력 | 일치 여부 |
|------|-----------|-----------|------------|
| ['h', 'e', 'l', 'l', 'o'] | ['o', 'l', 'l', 'e', 'h'] | ['o', 'l', 'l', 'e', 'h'] | ✅ |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(n/2) → O(n)
- **공간복잡도**: O(1) (in-place)

---

## ✅ 최종 정리

- 이 문제는 **in-place 배열 조작과 Two Pointer 패턴**을 연습하기 좋은 문제
- 포인터 인덱스 조작(`left++`, `right--`)과 교환 로직의 순서에 주의 필요
- `String`이 아닌 `char[]` 배열을 조작하는 문제라는 점도 포인트
- 보통 문자열 반전은 `StringBuilder`, `Collections.reverse()` 등을 떠올리지만,
  in-place로 제한되었기 때문에 저수준 배열 조작에 익숙해져야 함
