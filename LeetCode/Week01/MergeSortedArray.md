## 🧠 알고리즘 문제 코드 분석 - Merge Sorted Array

## 📌 문제 요약
- **문제 이름**: [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/)
- **문제 유형**: Two Pointer, 배열
- **난이도**: Easy
- **요구사항 요약**:
  - 정렬된 두 배열 `nums1`, `nums2`가 주어짐
  - `nums1`은 `m + n` 길이이며, 뒤쪽 `n`칸은 0으로 비워져 있음
  - `nums2`는 길이 `n`의 정렬된 배열
  - 두 배열을 **병합하여 정렬된 형태로 `nums1`에 in-place 저장**

---

## 📥 입력 & 출력 예시

### 입력 예시
```java
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6], n = 3
```

### 출력 예시
```java
[1,2,2,3,5,6]
```

---

## 🔍 접근 방식
- **입력 크기 분석**: 최대 2000개 → O(n) 충분
- **알고리즘 선택**: Two Pointer (역방향 병합)
- **이유**:
  - 배열 끝에서부터 채우면 in-place로 덮어쓰기 가능
- **핵심 아이디어**:
  - 두 배열 끝에서부터 비교하며 큰 값을 `nums1`의 뒤에서부터 채움
  - `nums2`가 남은 경우만 따로 복사해주면 됨

---

## 💻 핵심 코드 분석

```java
public static void merge(int[] nums1, int m, int[] nums2, int n) {
    int p1 = m - 1;
    int p2 = n - 1;
    int end = m + n - 1;

    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[end--] = nums1[p1--];
        } else {
            nums1[end--] = nums2[p2--];
        }
    }
    while (p2 >= 0) {
        nums1[end--] = nums2[p2--];
    }

    System.out.println(Arrays.toString(nums1));
}
```

- **설명**:
  - `p1`: nums1의 유효 구간 끝
  - `p2`: nums2 끝
  - `end`: 병합 결과를 넣을 nums1의 맨 끝 인덱스
  - 큰 값을 뒤에서부터 채우면 덮어쓰는 문제 없이 정렬 가능

---

## 🧪 예제 테스트

| nums1 | m | nums2 | n | 기대 출력 | 실제 출력 | 일치 여부 |
|-------|---|--------|---|------------|------------|------------|
| `[1,2,3,0,0,0]` | 3 | `[2,5,6]` | 3 | `[1,2,2,3,5,6]` | `[1,2,2,3,5,6]` | ✅ |
| `[0]` | 0 | `[1]` | 1 | `[1]` | `[1]` | ✅ |
| `[1]` | 1 | `[]` | 0 | `[1]` | `[1]` | ✅ |

---

## 📝 시간복잡도 및 공간복잡도

- **시간복잡도**: O(m + n)
- **공간복잡도**: O(1)
  - 추가 배열 없이 in-place 병합 수행

---

## ✅ 최종 정리

- 배열 끝에서부터 채우는 **역방향 투 포인터** 방식이 핵심
- 정렬된 배열 병합 문제는 매우 자주 등장하는 기본 문제
- in-place로 구현할 수 있다는 점에서 실용성이 높은 패턴